package io.github.dueris.originspaper.power.type;

import com.mojang.serialization.DataResult;
import io.github.dueris.calio.data.SerializableData;
import io.github.dueris.originspaper.condition.DamageCondition;
import io.github.dueris.originspaper.condition.EntityCondition;
import io.github.dueris.originspaper.condition.type.DamageConditionType;
import io.github.dueris.originspaper.condition.type.damage.AmountDamageConditionType;
import io.github.dueris.originspaper.data.TypedDataObjectFactory;
import io.github.dueris.originspaper.power.PowerConfiguration;
import net.minecraft.world.damagesource.DamageSource;
import org.jetbrains.annotations.NotNull;

import java.util.Optional;

public class InvulnerabilityPowerType extends PowerType {

	public static final TypedDataObjectFactory<InvulnerabilityPowerType> DATA_FACTORY = PowerType.createConditionedDataFactory(
		new SerializableData()
			.add("damage_condition", DamageCondition.DATA_TYPE.optional(), Optional.empty())
			.validate(data -> {

				DataResult<SerializableData.Instance> result = DataResult.success(data);
				Optional<DamageCondition> damageCondition = data.get("damage_condition");

				if (damageCondition.isPresent()) {

					DamageConditionType damageConditionType = damageCondition.get().getConditionType();
					DataResult<DamageConditionType> incompatible = DataResult.success(damageConditionType);

					return result.apply2stable((_data, _damageConditionType) -> _data, incompatible);

				} else {
					return result;
				}

			}),
		(data, condition) -> new InvulnerabilityPowerType(
			data.get("damage_condition"),
			condition
		),
		(powerType, serializableData) -> serializableData.instance()
			.set("damage_condition", powerType.damageCondition)
	);

	private final Optional<DamageCondition> damageCondition;

	public InvulnerabilityPowerType(Optional<DamageCondition> damageCondition, Optional<EntityCondition> condition) {
		super(condition);
		this.damageCondition = damageCondition;
	}

	public static DataResult<DamageConditionType> integrateDefaultIncompatibilityCallback(DamageConditionType damageConditionType) {
		return damageConditionType instanceof AmountDamageConditionType
			? DataResult.error(() -> "Using the 'amount' damage condition type is not allowed!")
			: DataResult.success(damageConditionType);
	}

	@Override
	public @NotNull PowerConfiguration<?> getConfig() {
		return PowerTypes.INVULNERABILITY;
	}

	public boolean doesApply(DamageSource source) {
		return damageCondition
			.map(condition -> condition.test(source, 0.0F))
			.orElse(true);
	}

	@FunctionalInterface
	public interface Incompatibility {
		DataResult<DamageConditionType> test(DamageConditionType damageConditionType);
	}

}
